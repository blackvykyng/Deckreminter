<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Inventory Stager â€” Calm Cards + Scan HUD</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #0f172a;
            --text: #e5e7eb;
            --muted: #94a3b8;
            --card: #0b1224;
            --border: #1f2937;
            --shadow: 0 12px 30px rgba(0, 0, 0, .28);
            --thumb: 96px;
        }

        .bigthumb:root {
            --thumb: 160px;
        }

        .light:root {
            --bg: #f8fafc;
            --panel: #ffffff;
            --text: #0f172a;
            --muted: #64748b;
            --card: #ffffff;
            --border: #e2e8f0;
            --shadow: 0 10px 20px rgba(2, 6, 23, .06)
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: var(--bg);
            color: var(--text)
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: color-mix(in oklab, var(--bg) 88%, transparent);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid var(--border)
        }

        .wrap {
            max-width: 980px;
            margin: 0 auto;
            padding: 14px 16px
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center
        }

        .title {
            font-weight: 800
        }

        .pill {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 9999px;
            border: 1px solid var(--border);
            color: var(--muted)
        }

        .input {
            background: var(--panel);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 12px;
            outline: none
        }

        .btn {
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700
        }

        .btn:active {
            transform: translateY(1px)
        }

        .btn.save {
            background: color-mix(in oklab, var(--panel) 85%, #065f46 15%)
        }

        .status {
            padding: 8px 12px;
            border: 1px dashed var(--border);
            border-radius: 12px;
            color: var(--muted)
        }

        .toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px
        }

        .columns {
            display: grid;
            grid-template-columns: 1fr;
            gap: 14px;
            margin-top: 12px
        }

        @media (min-width:860px) {
            .columns {
                grid-template-columns: 360px 1fr
            }
        }

        .results {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 10px;
            box-shadow: var(--shadow)
        }

        .results h3 {
            margin: 4px 6px 8px 6px;
            font-size: 14px;
            color: var(--muted)
        }

        .res {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 8px 10px;
            margin: 6px
        }

        .res .meta {
            font-size: 12px;
            color: var(--muted)
        }

        .cards {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px
        }

        @media (min-width:680px) {
            .cards {
                grid-template-columns: 1fr 1fr
            }
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 12px;
            box-shadow: var(--shadow)
        }

        .top {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 12px;
            align-items: start
        }

        .thumb {
            width: var(--thumb);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            background: linear-gradient(180deg, #0e162d, #0a1020)
        }

        .thumb .ph {
            width: 100%;
            aspect-ratio: 2/3;
            display: grid;
            place-items: center;
            color: var(--muted);
            font-size: 12px
        }

        .thumb img {
            width: 100%;
            height: auto;
            display: block
        }

        .meta {
            font-size: 12px;
            color: var(--muted)
        }

        .qty {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 8px 10px;
            border-radius: 12px;
            font-weight: 800;
            min-width: 64px;
            justify-content: center
        }

        .actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 8px
        }

        .mini {
            padding: 8px 10px;
            border-radius: 10px;
            font-weight: 700;
            border: 1px solid var(--border);
            background: var(--panel);
            min-width: 44px;
            text-align: center
        }

        .mini.minus {
            background: color-mix(in oklab, var(--panel) 85%, #7f1d1d 15%)
        }

        .mini.plus {
            background: color-mix(in oklab, var(--panel) 85%, #065f46 15%)
        }

        .mini.release {
            background: color-mix(in oklab, var(--panel) 85%, #1f2937 15%)
        }

        .mini.photo {
            background: color-mix(in oklab, var(--panel) 85%, #1e3a8a 15%)
        }

        .n {
            width: 80px;
            text-align: center
        }

        details {
            margin-top: 8px
        }

        details>summary {
            cursor: pointer;
            user-select: none;
            color: var(--muted)
        }

        .kv {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 6px;
            margin-top: 8px;
            font-size: 13px
        }

        .kv div:nth-child(odd) {
            color: var(--muted)
        }

        /* === Scan HUD === */
        .scanWrap {
            display: none;
            margin-top: 10px
        }

        .scanHud {
            position: relative;
            width: 100%;
            max-width: 520px
        }

        #preview {
            width: 100%;
            border: 1px solid var(--border);
            border-radius: 12px;
            display: block
        }

        .crosshair {
            position: absolute;
            inset: 10% 18%;
            border: 2px dashed color-mix(in oklab, var(--muted) 70%, transparent);
            border-radius: 16px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, .25) inset;
            pointer-events: none
        }

        .hudMsg {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: 10px;
            background: color-mix(in oklab, var(--panel) 90%, transparent);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 8px 12px;
            font-weight: 700;
            display: flex;
            gap: 8px;
            align-items: center
        }

        .hudMsg.ok {
            border-color: #059669;
            background: color-mix(in oklab, var(--panel) 70%, #065f46 30%)
        }

        .hudMsg.err {
            border-color: #dc2626;
            background: color-mix(in oklab, var(--panel) 75%, #7f1d1d 25%)
        }

        .pulse {
            animation: pulse 600ms ease-in-out 2
        }

        @keyframes pulse {
            0% {
                transform: translateX(-50%) scale(1)
            }

            50% {
                transform: translateX(-50%) scale(1.04)
            }

            100% {
                transform: translateX(-50%) scale(1)
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="wrap">
            <div class="row" style="justify-content:space-between;align-items:center">
                <div class="title">Inventory Stager <span class="pill">offline</span></div>
                <div class="row">
                    <span id="scannerSource" class="pill">Scanner: (not loaded)</span>
                    <span id="status" class="status">No file loaded</span>
                </div>
            </div>

            <div class="row" style="margin-top:10px">
                <input id="file" type="file" accept=".csv" class="input" />
                <input id="search" type="text" class="input" placeholder="Search (Barcode, Series, â€¦)"
                    style="min-width:220px" />
                <button id="scanBtn" class="btn">ðŸ“· Scan</button>
                <button id="testCam" class="btn" title="Quick permission/connection check">Test camera</button>
                <button id="hiResBtn" class="btn">Hi-Res</button>
                <button id="snapBtn" class="btn">Snap & Scan</button>
                <button id="torchBtn" class="btn" style="display:none">Torch</button>
                <input id="zoomSlider" type="range" min="1" max="1" step="0.1" value="1" class="input"
                    style="display:none;width:140px" title="Zoom">
            </div>

            <div class="scanWrap" id="scanArea">
                <div class="scanHud">
                    <video id="preview" playsinline></video>
                    <div class="crosshair" id="crosshair"></div>
                    <div class="hudMsg" id="hudMsg"><span id="hudStatus">Scanningâ€¦</span><span id="hudCode" class="pill"
                            style="display:none"></span></div>
                </div>
            </div>

            <div class="row" style="margin-top:8px">
                <span class="toggle"><input id="stageOnScan" type="checkbox" checked /> Stage first match on scan</span>
                <span class="toggle"><input id="editMode" type="checkbox" /> Edit mode</span>
                <span class="toggle"><input id="lightMode" type="checkbox" /> Light mode</span>
                <span class="toggle"><input id="bigPics" type="checkbox" /> Larger pictures</span>
                <input id="imgFiles" type="file" accept="image/*" multiple class="input"
                    title="Add images by barcode filename" />
                <button id="clearStaged" class="btn">Clear staged</button>
                <span id="counts" class="status">Staged: 0 â€¢ Results: 0</span>
            </div>
        </div>
    </div>

    <div class="wrap">
        <div class="columns">
            <div class="results">
                <h3 id="resultsTitle">Results</h3>
                <div id="resultsList"></div>
            </div>
            <div>
                <div class="cards" id="cards"></div>
                <div class="row" style="justify-content:flex-end;gap:10px;margin-top:10px">
                    <span>Adjust by</span>
                    <input id="by" type="number" min="1" value="1" class="input n" />
                    <button id="undo" class="btn">Undo</button>
                    <button id="save" class="btn save">Save CSV</button>
                </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <script>
        /* ===== ZXing loader with fallbacks + badge ===== */
        let ZX_SRC = '(none)';
        async function loadZXingIfNeeded() {
            if (window.ZXingBrowser) return 'inline';
            const UMDs = [
                ["local UMD", "./zxing-browser.min.js"], // local file first (put next to index.html)
                ["jsDelivr UMD", "https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/umd/zxing-browser.min.js"],
                ["unpkg UMD", "https://unpkg.com/@zxing/browser@0.1.5/umd/zxing-browser.min.js"],
                ["unpkg auto", "https://unpkg.com/@zxing/browser@0.1.5"]
            ];
            for (const [label, src] of UMDs) {
                try {
                    await new Promise((ok, err) => { const s = document.createElement('script'); s.src = src; s.async = true; s.onload = ok; s.onerror = err; document.head.appendChild(s); });
                    if (window.ZXingBrowser) { ZX_SRC = label; return label; }
                } catch (e) { }
            }
            const ESMS = [
                ["jsDelivr ESM", "https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/+esm"],
                ["esm.run ESM", "https://esm.run/@zxing/browser@0.1.5"]
            ];
            for (const [label, url] of ESMS) {
                try { const mod = await import(url); if (mod?.BrowserMultiFormatReader) { window.ZXingBrowser = mod; ZX_SRC = label; return label; } } catch (e) { }
            }
            return null;
        }
        const hasBarcodeDetector = "BarcodeDetector" in window;
        function setScannerSourceBadge() {
            const el = document.getElementById('scannerSource'); if (!el) return;
            el.textContent = 'Scanner: ' + (ZX_SRC || (hasBarcodeDetector ? 'BarcodeDetector' : '(not loaded)'));
        }

        /* ===== Utilities ===== */
        const E = id => document.getElementById(id);
        const statusEl = E('status'), toastEl = E('toast');
        function setStatus(msg) { statusEl.textContent = msg; }
        function toast(msg, kind = 'ok') {
            toastEl.className = 'toast ' + (kind === 'err' ? 'err' : 'ok'); toastEl.textContent = msg;
            toastEl.style.display = 'block'; clearTimeout(toastEl._t); toastEl._t = setTimeout(() => toastEl.style.display = 'none', 1800);
        }
        function digits(s) { return String(s || '').replace(/\D/g, ''); }

        /* ===== CSV helpers ===== */
        function parseCSV(text) {
            const out = [], headers = []; let i = 0, f = '', rec = [], q = false, c = '';
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            function endF() { rec.push(f); f = '' } function endR() { if (rec.length || f.length) { out.push(rec.slice()); rec.length = 0 } }
            while (i < text.length) {
                c = text[i++]; if (q) { if (c === '"') { if (text[i] === '"') { f += '"'; i++ } else q = false } else f += c }
                else { if (c === '"') q = true; else if (c === ',') endF(); else if (c === '\n') { endF(); endR() } else f += c }
            }
            endF(); endR(); if (!out.length) return { headers: [], rows: [] };
            const head = out.shift().map(h => h.trim()); head.forEach(h => headers.push(h));
            const rows = out.filter(r => r.some(c => (c ?? '').trim().length)).map(cols => { const o = {}; for (let j = 0; j < head.length; j++) o[head[j]] = cols[j] ?? ''; return o; });
            return { headers, rows };
        }
        function csvEscape(v) { const s = String(v ?? ''); const need = /[",\n]/.test(s); const esc = s.replace(/"/g, '""'); return need ? `"${esc}"` : esc; }
        function toCSV(headers, rows) { const lines = [headers.map(csvEscape).join(',')]; rows.forEach(o => lines.push(headers.map(h => csvEscape(o[h])).join(','))); return lines.join('\n'); }

        /* ===== State ===== */
        let headers = [], rows = [], history = [];
        let filtered = []; const stagedOrder = []; const stagedSet = new Set(); const indexByKey = new Map();
        let imageHeader = null; const imgMap = new Map(); const objURLs = new Set();

        /* ===== Elements ===== */
        const fileEl = E('file'), searchEl = E('search'), byEl = E('by');
        const stageOnScanEl = E('stageOnScan'), editModeEl = E('editMode'), lightModeEl = E('lightMode'), bigPicsEl = E('bigPics');
        const resultsList = E('resultsList'), resultsTitle = E('resultsTitle'), countsEl = E('counts');
        const cardsEl = E('cards');
        const scanBtn = E('scanBtn'), scanArea = E('scanArea'), videoEl = E('preview');
        const testCamBtn = E('testCam'), torchBtn = E('torchBtn'), zoomSlider = E('zoomSlider');
        const hudMsg = E('hudMsg'), hudStatus = E('hudStatus'), hudCode = E('hudCode'), crosshair = E('crosshair');
        const imgFilesEl = E('imgFiles');
        const hiResBtn = E('hiResBtn'), snapBtn = E('snapBtn');

        function findHeader(name) { const low = name.toLowerCase(); return headers.find(h => h.toLowerCase() === low); }
        function needHeaders() { if (!findHeader('Quantity')) throw new Error('Missing required column: Quantity'); if (!findHeader('Barcode')) throw new Error('Missing required column: Barcode'); }
        function detectImageHeader() { imageHeader = headers.find(h => /image|cover\s*image|cover\s*url|thumbnail/i.test(h)) || null; }
        function get(o, n) { const k = findHeader(n); return k ? o[k] : ''; }
        function setVal(o, n, v) { const k = findHeader(n); if (k) o[k] = v; }
        function qtyOf(o) { const n = Number(String(get(o, 'Quantity')).trim()); return Number.isFinite(n) ? Math.max(0, n) : 0; }
        function keyOf(o, idx) { const d = digits(get(o, 'Barcode')); return d ? `${d}#${idx}` : `row#${idx}`; }
        function updateIndex() { indexByKey.clear(); rows.forEach((o, i) => indexByKey.set(keyOf(o, i), i)); }
        function updateCounts() { countsEl.textContent = `Staged: ${stagedOrder.length} â€¢ Results: ${filtered.length}`; }

        /* ===== Scan HUD feedback ===== */
        let scanTicker = null, scanStart = 0, lastFoundAt = 0;
        function hudReset() { hudMsg.className = 'hudMsg'; hudStatus.textContent = 'Scanningâ€¦'; hudCode.style.display = 'none'; crosshair.style.borderColor = 'color-mix(in oklab, var(--muted) 70%, transparent)'; }
        function hudScanning() { hudMsg.className = 'hudMsg'; hudStatus.textContent = 'Scanningâ€¦'; hudCode.style.display = 'none'; crosshair.style.borderColor = 'color-mix(in oklab, var(--muted) 70%, transparent)'; }
        function hudHint() { hudMsg.className = 'hudMsg err pulse'; hudStatus.textContent = 'No barcode yet â€” try torch/zoom or steady hand'; hudCode.style.display = 'none'; }
        function hudSuccess(code, matches) {
            hudMsg.className = 'hudMsg ok pulse';
            hudStatus.textContent = matches != null ? `Found (${matches} match${matches === 1 ? '' : 'es'})` : 'Found';
            hudCode.textContent = code; hudCode.style.display = '';
            crosshair.style.borderColor = '#16a34a';
        }
        function startHudTimer() {
            clearInterval(scanTicker); scanStart = Date.now(); lastFoundAt = 0; hudScanning();
            scanTicker = setInterval(() => {
                const s = ((Date.now() - scanStart) / 1000).toFixed(1);
                if (!lastFoundAt) hudStatus.textContent = `Scanningâ€¦ ${s}s`;
                if (!lastFoundAt && Number(s) >= 4) hudHint();
            }, 250);
        }
        function stopHudTimer() { clearInterval(scanTicker); scanTicker = null; }

        /* Small beep for success */
        let audioCtx = null;
        function beep(freq = 900, ms = 120) {
            try {
                audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
                const o = audioCtx.createOscillator(), g = audioCtx.createGain();
                o.type = 'sine'; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination);
                const t = audioCtx.currentTime; g.gain.setValueAtTime(0.0001, t); g.gain.exponentialRampToValueAtTime(0.2, t + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t + ms / 1000); o.start(t); o.stop(t + ms / 1000 + 0.02);
            } catch (e) { }
        }

        /* ===== Images ===== */
        function urlForKey(key, o) {
            if (imgMap.has(key)) return imgMap.get(key);
            if (imageHeader) { const v = o[imageHeader]; if (v && /^https?:\/\//i.test(v)) return v; if (v && v.startsWith('data:image/')) return v; }
            return null;
        }
        imgFilesEl.addEventListener('change', async (e) => {
            const files = [...(e.target.files || [])]; if (!files.length) return;
            let assigned = 0; const by12 = new Map(), by17 = new Map();
            rows.forEach((o, i) => {
                const b = digits(get(o, 'Barcode')); if (!b) return; const k = keyOf(o, i);
                if (b.length >= 12) {
                    const d12 = b.slice(0, 12); (by12.get(d12) || by12.set(d12, []).get(d12)).push(k);
                    if (b.length >= 17) { const d17 = b.slice(0, 17); (by17.get(d17) || by17.set(d17, []).get(d17)).push(k); }
                }
            });
            for (const f of files) {
                const nameDigits = digits(f.name); let targets = null;
                if (nameDigits.length >= 17 && by17.get(nameDigits.slice(0, 17))) targets = by17.get(nameDigits.slice(0, 17));
                else if (nameDigits.length >= 12 && by12.get(nameDigits.slice(0, 12))) targets = by12.get(nameDigits.slice(0, 12));
                if (targets && targets.length) { const url = URL.createObjectURL(f); objURLs.add(url); targets.forEach(k => imgMap.set(k, url)); assigned += targets.length; }
            }
            toast(`Added images for ${assigned} item${assigned === 1 ? '' : 's'}`, 'ok'); renderCards();
        });

        /* ===== Staging ===== */
        function stageKey(key) { if (!indexByKey.has(key) || stagedSet.has(key)) return; stagedSet.add(key); stagedOrder.push(key); renderCards(); updateCounts(); }
        function releaseKey(key) { if (!stagedSet.has(key)) return; stagedSet.delete(key); const i = stagedOrder.indexOf(key); if (i >= 0) stagedOrder.splice(i, 1); renderCards(); updateCounts(); }
        E('clearStaged').addEventListener('click', () => { stagedSet.clear(); stagedOrder.length = 0; renderCards(); updateCounts(); });

        /* ===== Search/Results ===== */
        function applyFilter() {
            const qRaw = searchEl.value.trim(); const q = qRaw.toLowerCase(); const qDigits = digits(qRaw);
            const out = [];
            for (let i = 0; i < rows.length; i++) {
                const o = rows[i]; if (stagedSet.has(keyOf(o, i))) continue;
                let match = false;
                if (qDigits.length >= 6) {
                    const b = digits(get(o, 'Barcode'));
                    if (b.includes(qDigits)) match = true;
                    if (!match && qDigits.length === 17 && b.includes(qDigits.slice(0, 12))) match = true;
                    if (!match && qDigits.length === 12 && b.startsWith(qDigits)) match = true;
                }
                if (!match) { match = headers.some(h => String(o[h] ?? '').toLowerCase().includes(q)); }
                if (match) out.push({ o, i }); if (out.length >= 50) break;
            }
            filtered = out; renderResults(); updateCounts();
        }
        function renderResults() {
            resultsList.innerHTML = ''; resultsTitle.textContent = `Results (${filtered.length})`;
            if (!filtered.length) { resultsList.innerHTML = '<div class="meta" style="padding:10px">No matches yet. Type or scan to find items.</div>'; return; }
            filtered.forEach(({ o, i }) => {
                const title = `${get(o, 'Series') || '(No Series)'}${get(o, 'Issue Nr') ? ' â€” #' + get(o, 'Issue Nr') : ''}${get(o, 'Variant') ? ' â€¢ ' + get(o, 'Variant') : ''}`;
                const barcode = get(o, 'Barcode') || ''; const qty = qtyOf(o);
                const row = document.createElement('div'); row.className = 'res';
                const left = document.createElement('div');
                left.innerHTML = `<div style="font-weight:700">${title}</div><div class="meta">${barcode ? 'Barcode: ' + barcode : ''}  ${qty || qty === 0 ? 'â€¢ Qty: ' + qty : ''}</div>`;
                const right = document.createElement('div');
                const btn = document.createElement('button'); btn.className = 'btn'; btn.textContent = 'Stage';
                btn.addEventListener('click', () => { stageKey(keyOf(o, i)); toast('Staged', 'ok'); });
                right.appendChild(btn);
                row.appendChild(left); row.appendChild(right); resultsList.appendChild(row);
            });
        }

        /* ===== Cards (staged only) ===== */
        function renderCards() {
            cardsEl.innerHTML = '';
            document.documentElement.classList.toggle('light', E('lightMode').checked);
            document.documentElement.classList.toggle('bigthumb', E('bigPics').checked);
            if (!stagedOrder.length) { const empty = document.createElement('div'); empty.className = 'meta'; empty.style.padding = '12px'; empty.textContent = 'Nothing staged yet. Search or scan to stage items here.'; cardsEl.appendChild(empty); return; }
            const showEdits = E('editMode').checked;

            stagedOrder.forEach(key => {
                const idx = indexByKey.get(key); if (idx == null) return;
                const o = rows[idx];
                const title = `${get(o, 'Series') || '(No Series)'}${get(o, 'Issue Nr') ? ' â€” #' + get(o, 'Issue Nr') : ''}${get(o, 'Variant') ? ' â€¢ ' + get(o, 'Variant') : ''}`;
                const meta = `${get(o, 'Publisher') || ''}${get(o, 'Release Year') ? ' â€¢ ' + get(o, 'Release Year') : ''}`;
                const barcode = get(o, 'Barcode') || ''; const qty = qtyOf(o);

                const card = document.createElement('div'); card.className = 'card';
                const top = document.createElement('div'); top.className = 'top';

                const thumb = document.createElement('div'); thumb.className = 'thumb';
                const imgSrc = urlForKey(key, o);
                if (imgSrc) { const im = document.createElement('img'); im.loading = 'lazy'; im.alt = 'Cover'; im.src = imgSrc; thumb.appendChild(im); }
                else { const ph = document.createElement('div'); ph.className = 'ph'; ph.textContent = 'No image'; thumb.appendChild(ph); }

                const left = document.createElement('div');
                left.innerHTML = `<div style="font-weight:700">${title}</div>
                      <div class="meta">${barcode ? 'Barcode: ' + barcode : ''}${meta ? (barcode ? ' â€¢ ' : '') + meta : ''}</div>`;

                const right = document.createElement('div'); right.style.textAlign = 'right';
                const qtySpan = document.createElement('span'); qtySpan.className = 'qty'; qtySpan.textContent = qty; right.appendChild(qtySpan);

                top.appendChild(thumb); top.appendChild(left); top.appendChild(right); card.appendChild(top);

                const act = document.createElement('div'); act.className = 'actions';
                const releaseBtn = document.createElement('button'); releaseBtn.className = 'mini release'; releaseBtn.textContent = 'Release';
                releaseBtn.addEventListener('click', () => { releaseKey(key); toast('Released', 'ok'); });
                act.appendChild(releaseBtn);

                const photoBtn = document.createElement('button'); photoBtn.className = 'mini photo'; photoBtn.textContent = 'Add photo';
                photoBtn.addEventListener('click', () => { currentPhotoKey = key; hiddenPhotoInput.value = ''; hiddenPhotoInput.click(); });
                act.appendChild(photoBtn);

                const minus = document.createElement('button'); minus.className = 'mini minus'; minus.textContent = 'âˆ’';
                const plus = document.createElement('button'); plus.className = 'mini plus'; plus.textContent = '+';
                const nInp = document.createElement('input'); nInp.className = 'input n'; nInp.type = 'number'; nInp.min = '1'; nInp.value = Number(byEl.value) || 1;
                const setBtn = document.createElement('button'); setBtn.className = 'mini'; setBtn.textContent = 'Setâ€¦';

                function applyDelta(delta) {
                    const before = qtyOf(o);
                    const d = delta < 0 ? -Math.min(Math.abs(delta), before) : delta;
                    const after = before + d;
                    setVal(o, 'Quantity', String(after));
                    history.push({ index: idx, delta: d });
                    qtySpan.textContent = after;
                    setStatus(`Updated ${barcode} â†’ ${after}`); toast(`${d < 0 ? 'âˆ’' : '+'}${Math.abs(d)} ${get(o, 'Series') || get(o, 'Publisher') || ''}`, 'ok');
                    try { navigator.vibrate && navigator.vibrate(30); } catch { }
                }
                minus.addEventListener('click', () => applyDelta(-Math.max(1, Number(nInp.value) || 1)));
                plus.addEventListener('click', () => applyDelta(Math.max(1, Number(nInp.value) || 1)));
                setBtn.addEventListener('click', () => {
                    const v = prompt(`Set Quantity for:\n${title}\n${barcode}`, qtyOf(o));
                    if (v === null) return;
                    const newQty = Math.max(0, Number(v) || 0), delta = newQty - qtyOf(o);
                    setVal(o, 'Quantity', String(newQty)); history.push({ index: idx, delta });
                    qtySpan.textContent = newQty; setStatus(`Set ${barcode} â†’ ${newQty}`); toast(`Set to ${newQty}`, 'ok');
                });

                [minus, plus, nInp, setBtn].forEach(el => { el.style.display = showEdits ? '' : 'none'; act.appendChild(el); });
                card.appendChild(act);

                const det = document.createElement('details');
                const sum = document.createElement('summary'); sum.textContent = 'Details'; det.appendChild(sum);
                const kv = document.createElement('div'); kv.className = 'kv';
                const hide = new Set(['Series', 'Issue Nr', 'Variant', 'Publisher', 'Release Year', 'Barcode', 'Quantity', imageHeader]);
                headers.forEach(h => {
                    if (hide.has(h)) return;
                    const k = document.createElement('div'); k.textContent = h;
                    const v = document.createElement('div'); v.textContent = String(o[h] ?? '');
                    kv.appendChild(k); kv.appendChild(v);
                });
                det.appendChild(kv); card.appendChild(det);

                cardsEl.appendChild(card);
            });
        }

        /* ===== File + toggles ===== */
        fileEl.addEventListener('change', async (e) => {
            const f = e.target.files[0]; if (!f) return;
            const text = await f.text();
            try {
                const parsed = parseCSV(text); headers = parsed.headers; rows = parsed.rows; history = [];
                needHeaders(); detectImageHeader();
                stagedSet.clear(); stagedOrder.length = 0; updateIndex();
                searchEl.value = ''; filtered = []; renderResults(); renderCards(); updateCounts();
                setStatus(`${f.name}: ${rows.length} rows`); toast('File loaded', 'ok');
            } catch (err) { setStatus('Failed to load'); toast(String(err), 'err'); }
        });
        searchEl.addEventListener('input', applyFilter);
        byEl.addEventListener('change', () => renderCards());
        E('editMode').addEventListener('change', () => renderCards());
        E('lightMode').addEventListener('change', () => renderCards());
        E('bigPics').addEventListener('change', () => renderCards());

        /* ===== Undo & Save ===== */
        E('undo').addEventListener('click', () => {
            const last = history.pop(); if (!last) { toast('Nothing to undo'); return; }
            const o = rows[last.index]; if (!o) return;
            const now = qtyOf(o); const after = Math.max(0, now - last.delta);
            setVal(o, 'Quantity', String(after));
            toast('Undo complete', 'ok'); setStatus('Undo complete'); renderCards();
        });
        E('save').addEventListener('click', () => {
            if (!rows.length) { toast('No data loaded', 'err'); return; }
            const csv = toCSV(headers, rows);
            const blob = new Blob([csv], { type: 'text/csv' }); const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = URL.createObjectURL(blob); a.download = `inventory-updated-${ts}.csv`; a.click(); URL.revokeObjectURL(a.href);
            toast('Saved CSV', 'ok'); setStatus('Saved CSV to downloads');
        });

        /* ===== Scanner (ZXing from <video> + fallback + Torch/Zoom + HUD + Hi-Res + Snap & Scan) ===== */
        let reader = null, stream = null, camTrack = null, hiRes = false;

        function normalizeComicBarcode(text) {
            const m = String(text).replace(/[^\d+ ]/g, '').match(/(\d{12,13})(?:[ +\-]?(\d{2,5}))?/);
            return m ? { main: m[1], addon: m[2] || '' } : { main: text.trim(), addon: '' };
        }
        function setSearchFromBarcode(payload) {
            const { main, addon } = normalizeComicBarcode(payload);
            const combined = (main || '') + (addon || '');
            searchEl.value = combined || payload.trim();
            applyFilter();
            const matches = filtered.length;
            hudSuccess(combined || payload.trim(), matches);
            try { navigator.vibrate && navigator.vibrate(30); } catch { }
            beep();
            if (stageOnScanEl.checked && matches) {
                const best = filtered.find(({ o, i }) => {
                    const b = digits(get(o, 'Barcode'));
                    return combined && (b === combined || b.startsWith(combined) || combined.startsWith(b));
                }) || filtered[0];
                stageKey(keyOf(best.o, best.i));
                toast('Staged from scan', 'ok');
            }
        }

        async function stopScanner() {
            try { reader && reader.reset && reader.reset(); } catch { }
            try { reader && reader.stopStreams && reader.stopStreams(); } catch { }
            try { stream && stream.getTracks().forEach(t => t.stop()); } catch { }
            reader = null; stream = null; camTrack = null;
            scanArea.style.display = 'none';
            torchBtn.style.display = 'none'; zoomSlider.style.display = 'none';
            stopHudTimer(); hudReset();
        }

        async function setupCameraControls(s) {
            camTrack = (s && s.getVideoTracks && s.getVideoTracks()[0]) || null;
            if (!camTrack) { torchBtn.style.display = 'none'; zoomSlider.style.display = 'none'; return; }
            const caps = camTrack.getCapabilities ? camTrack.getCapabilities() : {};
            const setts = camTrack.getSettings ? camTrack.getSettings() : {};

            if (caps.torch) {
                torchBtn.style.display = '';
                let on = false; torchBtn.textContent = 'Torch: Off';
                torchBtn.onclick = async () => {
                    on = !on;
                    try { await camTrack.applyConstraints({ advanced: [{ torch: on }] }); torchBtn.textContent = on ? 'Torch: On' : 'Torch: Off'; }
                    catch { toast('Torch not available now', 'err'); }
                };
            } else torchBtn.style.display = 'none';

            if (typeof caps.zoom === 'number' || (caps.zoom && 'min' in caps.zoom)) {
                const min = caps.zoom.min ?? 1, max = caps.zoom.max ?? Math.max(1, Number(setts.zoom) || 2), step = caps.zoom.step ?? 0.1;
                zoomSlider.min = String(min); zoomSlider.max = String(max); zoomSlider.step = String(step);
                zoomSlider.value = String(setts.zoom ?? min); zoomSlider.style.display = '';
                zoomSlider.oninput = async () => {
                    try { await camTrack.applyConstraints({ advanced: [{ zoom: Number(zoomSlider.value) }] }); }
                    catch { try { await camTrack.applyConstraints({ zoom: Number(zoomSlider.value) }); } catch { } }
                };
            } else zoomSlider.style.display = 'none';
        }

        async function startScanner() {
            if (location.protocol === "file:") toast("Open via https:// or http://localhost â€” camera is usually blocked on file://", "err");

            const zxingOK = await loadZXingIfNeeded();
            setScannerSourceBadge();

            if (!zxingOK && !hasBarcodeDetector) {
                toast("Scanner lib not loaded and no BarcodeDetector. Whitelist cdn.jsdelivr.net / unpkg.com, or place zxing-browser.min.js next to this file.", "err");
                return;
            }

            scanArea.style.display = 'block';
            hudReset(); startHudTimer();

            // Preflight permission + frame size
            let preflight;
            try {
                preflight = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "environment",
                        width: { ideal: hiRes ? 1920 : 1280 },
                        height: { ideal: hiRes ? 1080 : 720 }
                    },
                    audio: false
                });
            } catch (e) {
                let msg = 'Camera error: ' + (e.name || '') + ' ' + (e.message || '');
                if (e.name === 'NotAllowedError') msg = 'Permission blocked. Use https or localhost, then tap â€œTest cameraâ€.';
                if (e.name === 'NotFoundError') msg = 'No camera found or accessible.';
                if (e.name === 'NotReadableError') msg = 'Camera is busy (another app is using it).';
                if (e.name === 'SecurityError') msg = 'Insecure origin. Use https:// or http://localhost.';
                toast(msg, 'err'); scanArea.style.display = 'none'; stopHudTimer(); return;
            }

            videoEl.srcObject = preflight; await videoEl.play();
            await setupCameraControls(preflight);

            // Try to swap to explicit back camera if ZXing is present
            try {
                if (zxingOK) {
                    const ZX = window.ZXingBrowser;
                    const devices = await ZX.BrowserMultiFormatReader.listVideoInputDevices();
                    const back = devices.find(d => /back|rear|environment/i.test(d.label)) || devices[0];
                    if (back?.deviceId) {
                        preflight.getTracks().forEach(t => t.stop());
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                deviceId: { exact: back.deviceId },
                                width: { ideal: hiRes ? 1920 : 1280 },
                                height: { ideal: hiRes ? 1080 : 720 }
                            },
                            audio: false
                        });
                        videoEl.srcObject = stream; await videoEl.play(); await setupCameraControls(stream);
                    } else { stream = preflight; }
                } else { stream = preflight; }
            } catch (e) { console.warn('Back-camera swap failed, using preflight stream:', e); stream = preflight; }

            // Decode from the already-playing <video>
            if (zxingOK) {
                const { BrowserMultiFormatReader, BarcodeFormat, DecodeHintType } = window.ZXingBrowser;
                reader = new BrowserMultiFormatReader(new Map([
                    [DecodeHintType.POSSIBLE_FORMATS, [BarcodeFormat.EAN_13, BarcodeFormat.EAN_8, BarcodeFormat.UPC_A, BarcodeFormat.UPC_E]],
                    [DecodeHintType.TRY_HARDER, true],
                    [DecodeHintType.ALLOWED_EAN_EXTENSIONS, [2, 5]] // comic +2/+5
                ]), 200);

                reader.decodeFromVideoElementContinuously(videoEl, (result, err) => {
                    if (result && result.text) {
                        lastFoundAt = Date.now();
                        const code = result.text.replace(/\s+/g, '');
                        setSearchFromBarcode(code);
                        setTimeout(() => stopScanner(), 150);
                    }
                    // ignore NotFoundException frames
                });

            } else {
                const detector = new BarcodeDetector({ formats: ['ean_13', 'ean_8', 'upc_a', 'upc_e'] });
                const loop = async () => {
                    if (!stream) return;
                    try {
                        const codes = await detector.detect(videoEl);
                        if (codes && codes[0]?.rawValue) {
                            lastFoundAt = Date.now();
                            const code = codes[0].rawValue.replace(/\s+/g, '');
                            setSearchFromBarcode(code);
                            await stopScanner(); return;
                        }
                    } catch (e) { }
                    requestAnimationFrame(loop);
                };
                loop();
            }
        }

        scanBtn.addEventListener('click', async () => {
            try { if (reader || stream) await stopScanner(); else await startScanner(); }
            catch (err) { toast('Camera unavailable. Try https:// or localhost.', 'err'); console.error(err); }
        });

        /* Test camera */
        testCamBtn.addEventListener('click', async () => {
            try { const st = await navigator.mediaDevices.getUserMedia({ video: true, audio: false }); st.getTracks().forEach(t => t.stop()); toast('Camera test: OK', 'ok'); }
            catch (e) {
                let msg = 'Camera test failed: ' + (e.name || '') + ' ' + (e.message || '');
                if (e.name === 'NotAllowedError') msg = 'Permission blocked. Enable it in browser/site settings (use https or localhost).';
                if (e.name === 'NotFoundError') msg = 'No camera found or not accessible.';
                if (e.name === 'SecurityError') msg = 'Insecure origin. Use https:// or http://localhost.';
                if (e.name === 'NotReadableError') msg = 'Camera is busy (another app is using it).';
                toast(msg, 'err');
            }
        });

        /* ===== Hi-Res toggle ===== */
        hiResBtn.addEventListener('click', async () => {
            hiRes = !hiRes;
            hiResBtn.textContent = hiRes ? 'Hi-Res: On' : 'Hi-Res';
            if (reader || stream) { await stopScanner(); await startScanner(); }
        });

        /* ===== Snap & Scan ===== */
        function cropToCrosshairCanvas() {
            const v = videoEl; const box = crosshair.getBoundingClientRect(); const vid = v.getBoundingClientRect();
            const vw = v.videoWidth || 1280, vh = v.videoHeight || 720;
            if (!vw || !vh) return null;
            const sx = Math.max(0, Math.round((box.left - vid.left) / vid.width * vw));
            const sy = Math.max(0, Math.round((box.top - vid.top) / vid.height * vh));
            const sw = Math.min(vw - sx, Math.round(box.width / vid.width * vw));
            const sh = Math.min(vh - sy, Math.round(box.height / vid.height * vh));
            const c = document.createElement('canvas');
            c.width = sw; c.height = sh;
            c.getContext('2d').drawImage(v, sx, sy, sw, sh, 0, 0, sw, sh);
            return c;
        }
        async function decodeCanvas(c) {
            if ('BarcodeDetector' in window) {
                try {
                    const det = new BarcodeDetector({ formats: ['ean_13', 'ean_8', 'upc_a', 'upc_e'] });
                    const res = await det.detect(c);
                    if (res && res[0]?.rawValue) return res[0].rawValue;
                } catch { }
            }
            try {
                const ZX = window.ZXingBrowser;
                if (ZX?.BrowserMultiFormatReader) {
                    const { BrowserMultiFormatReader, BarcodeFormat, DecodeHintType } = ZX;
                    const r = new BrowserMultiFormatReader(new Map([
                        [DecodeHintType.POSSIBLE_FORMATS, [BarcodeFormat.EAN_13, BarcodeFormat.EAN_8, BarcodeFormat.UPC_A, BarcodeFormat.UPC_E]],
                        [DecodeHintType.TRY_HARDER, true],
                        [DecodeHintType.ALLOWED_EAN_EXTENSIONS, [2, 5]]
                    ]), 200);
                    const out = await r.decodeFromCanvas(c);
                    if (out?.text) return out.text;
                }
            } catch { }
            return null;
        }
        snapBtn.addEventListener('click', async () => {
            if (!stream) { toast('Tap ðŸ“· Scan first', 'err'); return; }
            hudStatus.textContent = 'Analyzingâ€¦'; hudMsg.className = 'hudMsg';
            let canvas = null;

            // Prefer a sharp grab via ImageCapture if available
            try {
                const track = (stream.getVideoTracks && stream.getVideoTracks()[0]) || null;
                if ('ImageCapture' in window && track) {
                    const cap = new ImageCapture(track);
                    const blob = await cap.takePhoto({ imageWidth: hiRes ? 2592 : 1920 });
                    const img = await createImageBitmap(blob);
                    const full = document.createElement('canvas');
                    full.width = img.width; full.height = img.height;
                    full.getContext('2d').drawImage(img, 0, 0);

                    // Crop proportions from live crosshair
                    const v = videoEl;
                    const box = crosshair.getBoundingClientRect();
                    const vid = v.getBoundingClientRect();
                    const sx = Math.max(0, Math.round((box.left - vid.left) / vid.width * img.width));
                    const sy = Math.max(0, Math.round((box.top - vid.top) / vid.height * img.height));
                    const sw = Math.min(img.width - sx, Math.round(box.width / vid.width * img.width));
                    const sh = Math.min(img.height - sy, Math.round(box.height / vid.height * img.height));

                    canvas = document.createElement('canvas'); canvas.width = sw; canvas.height = sh;
                    canvas.getContext('2d').drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
                }
            } catch { /* ignore & fall back */ }

            if (!canvas) canvas = cropToCrosshairCanvas();
            if (!canvas) { toast('No frame yet â€” try again', 'err'); return; }

            const code = await decodeCanvas(canvas);
            if (code) {
                setSearchFromBarcode(code.replace(/\s+/g, ''));
                setTimeout(() => stopScanner(), 200);
            } else {
                hudHint();
                toast('No code in snapshot â€” move closer, try torch/zoom', 'err');
            }
        });

        /* Add photo (per-card) */
        let currentPhotoKey = null;
        const hiddenPhotoInput = document.createElement('input');
        hiddenPhotoInput.type = 'file'; hiddenPhotoInput.accept = 'image/*'; hiddenPhotoInput.capture = 'environment'; hiddenPhotoInput.style.display = 'none';
        hiddenPhotoInput.addEventListener('change', () => {
            const f = hiddenPhotoInput.files[0]; if (!f || !currentPhotoKey) return;
            const url = URL.createObjectURL(f); objURLs.add(url); imgMap.set(currentPhotoKey, url); currentPhotoKey = null; renderCards();
        });
        document.body.appendChild(hiddenPhotoInput);

        /* Cleanup */
        window.addEventListener('beforeunload', () => { objURLs.forEach(u => URL.revokeObjectURL(u)); });

        /* ===== Results & rendering helpers ===== */
        function updateCounts() { countsEl.textContent = `Staged: ${stagedOrder.length} â€¢ Results: ${filtered.length}`; }

        /* Init badge */
        setScannerSourceBadge();
    </script>
</body>

</html>